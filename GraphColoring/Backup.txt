#include "graph_coloring.h"

#include <stdexcept>
#include <mpi.h>
#include <math.h>
#include <vector>
#include <iostream>
#include <thread>
#include <mutex>

extern std::vector<std::string> colors = std::vector<std::string>();

std::mutex mx;

bool is_color_valid(int node, const std::vector<int>& codes, Graph& graph)
{
    for (auto n_node : graph.neighbours(node)) {
        if (n_node < node && codes[n_node] == codes[node]) {
            return false;
        }
    }

    return true;
}

std::map<int, std::string> get_nodes_to_colors(const std::vector<int>& codes)
{
    std::map<int, std::string> res;

    for (size_t i = 0; i < codes.size(); ++i) {
        res[i] = colors[codes[i]];
    }

    return res;
}

std::map<int, std::string> graph_coloring_threads(int nr_threads, Graph& graph)
{
    std::vector<int> codes = std::vector<int>(graph.nodes().size());
    std::vector<int> res_codes;

    graph_coloring_util_threads(nr_threads, 0, codes, res_codes, graph);

    if (res_codes.empty())
        throw std::runtime_error("No solution found!");

    return get_nodes_to_colors(res_codes);
}

void graph_coloring_util_threads(int nr_threads, int node, std::vector<int> codes, std::vector<int>& res_codes, Graph& graph)
{
    if (!res_codes.empty())
        return;

    if (node + 1 == graph.nodes().size()) {
        if (is_color_valid(node, codes, graph)) {
            std::lock_guard<std::mutex> lk(mx);

            if (res_codes.empty()) {
                res_codes.insert(res_codes.begin(), codes.begin(), codes.end());
            }
        }

        return;
    }

    int next_node = node + 1;

    std::vector<std::thread> threads;
    std::vector<int> valid_codes;

    for (int code = 0; code < colors.size(); ++code) {
        codes[next_node] = code;

        if (is_color_valid(next_node, codes, graph)) {

            if (nr_threads - 1 > 0) {
                auto next_codes = codes;

                threads.emplace_back([nr_threads, next_node, next_codes, &res_codes, &graph] {graph_coloring_util_threads(nr_threads - 1, next_node, next_codes, res_codes, graph); });
            }
            else {
                valid_codes.push_back(code);
            }
        }
    }

    for (auto& thread : threads) {
        thread.join();
    }

    for (int code : valid_codes) {
        codes[next_node] = code;
        auto next_codes = codes;

        graph_coloring_util_threads(nr_threads - 1, next_node, next_codes, res_codes, graph);;
    }
}

std::map<int, std::string> graph_coloring_master(int mpi_size, Graph& graph)
{
    auto codes = graph_coloring_util(0, mpi_size, 0, 0, std::vector<int>(graph.nodes().size(), 0), graph);

    if (codes[0] == -1)
        throw std::runtime_error("No solution found!");

    return get_nodes_to_colors(codes);
}

void graph_coloring_worker(int id, int mpi_size, int nr_codes, Graph& graph)
{
    std::vector<int> data(3, 0);
    std::cout << id << ": graph_coloring_worker() - MPI_Recv() : 1\n";
    MPI_Recv(data.data(), data.size(), MPI_INT, MPI_ANY_SOURCE, MPI_ANY_TAG, MPI_COMM_WORLD, MPI_STATUS_IGNORE);

    int parent = data[0];
    int node = data[1];
    int power = data[2];

    std::vector<int> codes(graph.nodes().size(), 0);
    std::cout << id << ": graph_coloring_worker() - MPI_Recv() : 2\n";
    MPI_Recv(codes.data(), codes.size(), MPI_INT, MPI_ANY_SOURCE, MPI_ANY_TAG, MPI_COMM_WORLD, MPI_STATUS_IGNORE);

    auto new_codes = graph_coloring_util(id, mpi_size, node, power, codes, graph);

    std::cout << id << ": graph_coloring_worker() - MPI_Bsend() : 1\n";
    MPI_Bsend(new_codes.data(), new_codes.size(), MPI_INT, parent, 0, MPI_COMM_WORLD);
}

std::vector<int> graph_coloring_util(int id, int mpi_size, int node, int power, const std::vector<int>& codes, Graph& graph)
{
    if (!is_color_valid(node, codes, graph)) {
        return std::vector<int>(graph.nodes().size(), -1);
    }

    if (node + 1 == graph.nodes().size()) {
        return codes;
    }

    int coeff = static_cast<int>(pow(colors.size(), power));
    int code = 0;
    int destination = id + coeff * (code + 1);

    while (code < colors.size() - 1 && destination <= mpi_size) {
        ++code;
        destination = id + coeff * (code + 1);
    }

    int next_node = node + 1;
    int next_power = power + 1;

    for (int c_code = 1; c_code < code; ++c_code) {
        destination = id + coeff * c_code;

        std::vector<int>data = { id, next_node, power };

        std::cout << id << ": graph_coloring_util() - MPI_Bsend() : 1 to " << destination << "\n";
        MPI_Bsend(data.data(), data.size(), MPI_INT, destination, 0, MPI_COMM_WORLD);

        auto next_codes = codes;
        next_codes[next_node] = c_code;

        std::cout << id << ": graph_coloring_util() - MPI_Bsend() : 2 to " << destination << "\n";
        MPI_Bsend(next_codes.data(), next_codes.size(), MPI_INT, destination, 0, MPI_COMM_WORLD);
    }

    auto next_codes = codes;
    next_codes[next_node] = 0;

    auto res = graph_coloring_util(id, mpi_size, next_node, next_power, next_codes, graph);

    if (res[0] != -1) {
        return res;
    }

    for (int c_code = 1; c_code < code; ++c_code) {
        destination = id + coeff * c_code;

        std::vector<int> res(graph.nodes().size(), 0);
        std::cout << id << ": graph_coloring_util() - MPI_Recv() : 1 from " << destination << "\n";
        MPI_Recv(res.data(), res.size(), MPI_INT, destination, MPI_ANY_TAG, MPI_COMM_WORLD, MPI_STATUS_IGNORE);

        if (res[0] != -1) {
            return res;
        }
    }

    for (int c_code = code; c_code < colors.size(); ++c_code) {
        auto next_codes = codes;
        next_codes[next_node] = c_code;

        auto res = graph_coloring_util(id, mpi_size, next_node, next_power, next_codes, graph);

        if (res[0] != -1) {
            return res;
        }
    }

    return res;
}
